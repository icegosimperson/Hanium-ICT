1. 작성 날짜 : 2023, 0509

2. 공부 내용 : 

#8 Map 

1) Map의 선언 방법

  // Map 기본 선언 방법
  Map dictionary={
  'key': 'value',
  'apple':'사과',
  'banana':'바나나',  
  };
  
  // Map<key, value> 타입으로 선언 
   Map<String, int> price={ 
   'apple':2000,
   'banana':4000,
   'watermelon':10000,
  };
 

2) Map은 key값을 넣어 value값을 알 수 있다. (인덱스값을 넣지 않음)

void main() {
  Map dictionary={
  'key': 'value',
  'apple':'사과',
  'banana':'바나나',  
  };
  
  print(dictionary); 
  print(dictionary['apple']);
  print(dictionary['apple']); // 인덱스값을 넣지 않고 Map은 key값을 넣어 value값을 알 수 있다.
  print(dictionary['사과']); // null 출력됨, value값을 넣어 key값을 알 수는 없다. 
  }
value값을 넣어 key값을 알 수는 없다. null 출력


 

3) Map 의 원소 추가, 삭제, 변경 방식

  // Map 원소 추가  : Map이름.addAll
  dictionary2.addAll({ 
    'key':'value',
    'apple':'사과',
    'banana':'바나나',
  });
  print(dictionary2);
  
  // Map 원소 삭제 : remove('key');
  dictionary2.remove('apple'); // key값을 이용해서 삭제 
  print(dictionary2);
  
  // Map 원소 변경
  dictionary2['banana']='바나나'; // banana-> 바나나로 변경 
  print(dictionary2);
  print(dictionary2['banana']); // 변경 전 값을 출력해도, 변경 한 값이 출력

4) Map의 key값과 value값을 list로 출력할 수 있다.

  print(dictionary2.keys.toList()); // key값들만 리스트로 출력 
  print(dictionary2.values.toList()); // value값들만 리스트로 추력


 

5)   Map 에서 key는 절대적으로 unique해야 한다. 

  print(price);
  
  price.addAll({
    'apple' : 50000
  });
  print(price);

#9 Nullable vs Non-nullable 

1) "변수타입? 변수명;"으로 null값을 넣을 수 있는 변수를 선언할 수 있다. 

void main(){
  // nullable - null이 될 수 있다.
  // non-nullable - null이 될 수 없다.
  // null - 아무런 값도 있지 않다.
  String name = 'Dart';
  // name = null -> error 불가능 
  print(name);

  String? name2 = 'Flutter';
  name2 = null; 
  print(name2);
}

- "변수!"를 사용하여 변수가 null값이 아니라는걸 알 수 있다. 

void main(){
  // nullable - null이 될 수 있다.
  // non-nullable - null이 될 수 없다.
  // null - 아무런 값도 있지 않다.
  String name = 'Dart';
  // name = null -> error 불가능 
  print(name);

  String? name2 = 'Flutter';
  print(name2!);
}

#9 final vs const

void main(){
  // final과 const 공통점 : var 역할을 해서 변수 타입을 따로 선언하지 않아도 된다.
  final name = 'Dart'; // =(final String name = 'Dart';)
  print(name);
  //name = 'Flutter';
  
  const name2 = 'Dart'; // =(const String name2 = 'Dart';)
  print(name2);
  //name2 = 'Flutter';
  
  // final과 const 차이점
  final DateTime now = DateTime.now(); // bulid Time을 몰라도 실행 가능 
  print(now);
  
  // error 발생 
  // const DateTime now2 = DateTime.now(); // bulid Time을 알아야 실행 가능 
  
  // bulid Time이란 코드를 작성하는 순간의 시간 
}
- final과 const 공통점 : var 역할을 해서 변수 타입을 따로 선언하지 않아도 된다.

- final과 const 차이점 :  final(bulid Time을 몰라도 실행 가능) vs const(bulid Time을 알아야 실행 가능)

* bulid Time :  코드를 작성하는 순간의 시간 

 

#10 연산자

1) ??= 연산자 : 해당 변수가 null값이면 해당 값으로 대체 

void main(){
  double? number = 4.0;
  print(number);
  
  number=2.0;
  print(number);
  
  number=null;
  print(number);
  
  number ??=3.0; // number 값이 null이면 3.0 값으로 대체 
  print(number);
}

 

 

# 11 Set 

1) Set은 중복 값을 처리할 수 있다. List(중복 값 가능) vs Set(중복 값 불가) 

  final Set<String> s_names={
    'Dart',
    'Flutter',
  };
  print(s_names);
  
  // Set 원소 추가 : Set이름.add
  s_names.add('Language');
  print(s_names);
  
  // Set 원소 제거 : Set이름.remove
  s_names.remove('Language');
  print(s_names);
  
  // Set 원소에 해당하는지 확인, 해당하면 true 출력
  print(s_names.contains('Flutter'));

# 12 for-in-loop

1) for in loop : list에 있는 값을 하나씩 변수에 넣어준다. 

void main(){
  int total =0;
  List<int> numbers=[1, 2, 3, 4, 5, 6];
  
  for(int i=0; i<numbers.length; i++){
    total += numbers[i];
  }
  print(total);
  
  total=0;
  
  for(int number in numbers){
    total+=number;
  }
  
  print(total);
}
두 반복문은 동일

 

2) continue는 해당 반복문만 Skip 한다

void main(){
  //while loop
  for(int i=0; i<10; i++){
    if(i==5){
      continue; // 해당 반복문만 skip
    }
    print(i);
  }
}

5 제외하고 출력
현재 loop을 종료하고 다음 loop을 실행하기 때문 

 

# 13 enum : main문 밖에서 실행해야한다, 사용하는 이유 : 자료형의 개수를 명확히 알고 오타를 손쉽게 찾기 위함

enum Status{ //main 밖에서 선언해야 한다. 
  approved,
  pending,
  rejected,
}

void main(){
  Status status = Status.approved;
  
  if(status==Status.approved){
    print('승인입니다.');
  }else if(status==Status.pending){
    print('대기입니다.');
  }else{
    print('거절입니다.');
  }
}
#14 함수

1) optional parmeter : 있어도되고 없어도되는 파라미터 [ ]

void main(){
  addNumbers(10, 50, 60);
  addNumbers(20, 90, 100);
}

// 세개의 숫자 (x, y, z)를 더하고 짝수인지 홀수인지 알려주는 함수
// parameter / arugment - 매개변수
// positional parameter - 순서가 중요한 파라미터
// optional parameter - 있어도 되고 없어도 되는 파라미터

addNumbers(int x, [int y=20, int z=30]){
  int sum=x+y+z;
  
  print('x:$x');
  print('y:$y');
  print('z:$z');
  
  if(sum%2==0){
    print('짝수입니다.');
  }else{
    print('홀수입니다.');
  }
}
2) named parameter : 이름이 있는 파라미터 (순서 중요 X)

void main(){
  addNumbers(z:10, y:50, x:60);
  addNumbers(x:20, z:90, y:100);
}

// 세개의 숫자 (x, y, z)를 더하고 짝수인지 홀수인지 알려주는 함수
// parameter / arugment - 매개변수
// positional parameter - 순서가 중요한 파라미터
// optional parameter - 있어도 되고 없어도 되는 파라미터
// named parameter - 이름이 있는 파라미터 (순서 중요X)
addNumbers({
  required int x, //named paramter에서 required를 없애면 optional parameter 사용 가능
  required int y,
  required int z,
}){
  int sum=x+y+z;
  
  print('x:$x');
  print('y:$y');
  print('z:$z');
  
  if(sum%2==0){
    print('짝수입니다.');
  }else{
    print('홀수입니다.');
  }
}
 

3) arrow function (화살표 함수)

void main(){
  int result = addNumbers(10, y: 20);
  print('sum: ${result}');
}

// 세개의 숫자 (x, y, z)를 더하고 짝수인지 홀수인지 알려주는 함수
// arrow function - 화살표 함수 
addNumbers(int x, {
  required int y,
  int z=30,
}) => x+y+z;

 

# 14 Typedef : 함수와 유사하지만 함수의 body가 없음 

void main(){
  Operation operation = add;
  int result = calculate(30, 40, 50, add);
  print(result);
  
  int result2 = calculate(40, 50, 60, subtract);
  print(result2);
}

// signature
typedef Operation = int Function(int x, int y, int z);

int add(int x, int y, int z) => x+y+z;
int subtract(int x, int y, int z) => x-y-z;

// 계산 
int calculate(int x, int y, int z, Operation operation){
  return operation(x, y, z);
}
사용시 Typedef에 선언된 siganiture에 부합하는 모든 함수를 선언할 수 있다. 

 

3. 기억에 남는 점

C의 %역할과 dart의 $역할이 유사한 것같다 

 

4. 참고 레퍼런스 : https://www.youtube.com/watch?v=3Ck42C2ZCb8
